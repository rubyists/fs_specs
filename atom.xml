<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[FreeSWITCH And FreeSWITCHeR Ruby Library]]></title>
  <link href="http://rubyists.github.com/fs_specs/atom.xml" rel="self"/>
  <link href="http://rubyists.github.com/fs_specs/"/>
  <updated>2012-02-20T22:32:17-05:00</updated>
  <id>http://rubyists.github.com/fs_specs/</id>
  <author>
    <name><![CDATA[Deryl R. Doucette]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Anatomy of an FS_SPECS Feature Set - 000_phone_infrastructure.feature]]></title>
    <link href="http://rubyists.github.com/fs_specs/blog/2012/02/20/anatomy-of-an-fs-specs-feature-set-000-phone-infrastructure-feature/"/>
    <updated>2012-02-20T22:29:00-05:00</updated>
    <id>http://rubyists.github.com/fs_specs/blog/2012/02/20/anatomy-of-an-fs-specs-feature-set-000-phone-infrastructure-feature</id>
    <content type="html"><![CDATA[<p>FS_SPECS Stable Branch - master</p>

<p>As I stated earlier, our ‘master’ branch on GitHub is the ‘Stable Release’ branch for fs_specs. As of today’s date, we currently have 4 Features that test different aspects of FreeSWITCH through FreeSWITCHeR. They are:</p>

<p>000_phone_infrastructure.feature
001_channel_can_dial_extensions.feature
002_channel_can_interact_with_voicemail.feature
003_can_retrieve_channel_information.feature</p>

<p>Over the next few articles I’ll be diving into the anatomy of each feature, the attendant steps, and the FSL::Inbound *Listener classes for each.</p>

<p>Core Feature - 000_phone_infrastructure.feature</p>

<p>Feature: Establish that phone infrastructure is working<br/>
If we have 2 properly configured freeswitch servers,
   we want to ensure we can make a connection between the 2 of them,
   and properly terminate that connection.</p>

<p>   Background:
   Given I have 2 servers named blackbird.rubyists.com and tigershark.rubyists.com
   And blackbird.rubyists.com is accessible via the Event Socket</p>

<p>   Scenario: Show that True and False express correctly, and exactly, with should and should_not
   Then true.should == true
   And  false.should != true</p>

<p>   Scenario:
   When I make a phone call
   Then I should be able to terminate the call</p>

<p>   This feature is the key to the entire set, both existing and those to come. The reason for this is the features job is solely to establish that you have a working configuration for running the rest of the features. If this particular feature fails nothing else will work.</p>

<p>   To see what this feature is actually doing, lets open up the associated ‘steps.rb’ file and look for the matchers that comprise each step of each Scenario as they go along. Background in each feature file sets up stuff we need to make it all work and keeps it existing for each Scenario in the feature rather than tearing it all down in-between each one.</p>

<p>   As we can see from the feature title, this feature set establishes that the phone infrastructure for all remaining tests can be found and is correctly configured. In the Background segment’s Given line, we are checking to ensure we can access both machines listed. The first server listed (blackbird.rubyists.com) is a freeswitch that is being used basically as nothing more than a soft phone. The second server listed (tigershark.rubyists.com) is the actual freeswitch being tested. The And line ensures that we can talk to the soft phone (blackbird) via freeswitch’s EventSocket.</p>

<p>   In the first Scenario, we establish the validity of both ‘true’ and ‘false’ values which establishes the credibility of all remaining tests. If ‘true’ and ‘false’ really aren’t what values they say they are, not a chance in the Universe you can be positive any positive or negative results are valid. Since this is our initialization feature, we put it as the first Scenario.</p>

<p>   In the final Scenario, we concretely establish our baseline configuration by ensuring we can originate a call to freeswitch, and that we can, in turn, terminate that call. The steps which comprise this Feature are as follows:</p>

<p>   Background:
   Given /<sup>I</sup> have 2 servers named ([\w.]+) and ([\w.]+)$/ do |server1, server2|
  @server1, @server2 = server1, server2
@sock1 = FSR::CommandSocket.new(server: @server1, port: 8021)
  @played_files = []
  end</p>

<p>  Given /<sup>([\w.]+)</sup> is accessible via the Event Socket$/ do |es_server|
@sock2 = FSR::CommandSocket.new(server: @server1)
  @sock2.should_not be_nil
  end</p>

<p>  Scenario:
  Then /<sup>true.should</sup> == true$/ do
  true.should == true
  end</p>

<p>  Then /<sup>false.should</sup> != true$/ do
  false.should_not == true
  end</p>

<p>  Scenario:
  When /<sup>I</sup> make a phone call$/ do
orig = @sock2.originate(target: “sofia/external/3000@#{@server2}”, endpoint: ‘&amp;transfer(9664)’)
  @uuid = orig.run(:api)[‘body’].split[1]</p>

<h1>Due to asynchronous nature of the entire method chain</h1>

<h1>which involves network stack, call plans, etc..</h1>

<h1>We sleep long enough for the call creations have been handled <em>throughout</em> the stack.</h1>

<h1>We limit our sleep times to &lt; 1s in order to wait the last amount of time,</h1>

<h1>and include additional checks oxide the sleep to limit wait time further.</h1>

<p>  30.times do
  sleep 0.1
  break if @sock2.calls.run.any?{|call| call.uuid == @uuid }
  end
  our_call = @sock2.calls.run.detect { |call| call.uuid == @uuid }
  fail “No Call Exists!” unless our_call and our_call.uuid == @uuid
  end</p>

<p>  Then /<sup>I</sup> should be able to terminate the call$/ do
  @uuid.should_not be_nil</p>

<p>resp = @sock2.kill(@uuid).run(:api)</p>

<p>resp[“body”].should match(/<sup>+OK/)</sup></p>

<p>  30.times do
  sleep 0.1
  break unless @sock2.calls.run.detect { |c| c.uuid == @uuid }
  end</p>

<h1>Make sure there are no calls left still dangling</h1>

<p>  @sock2.calls.run.detect { |c| c.uuid == @uuid }.should be_nil
  end</p>

<p>  To distill that all down, in the Background we define several ivars for use elsewhere in the Feature, such as @server1, @server2, and use them to open a FSR::CommandSocket to ‘blackbird’, our ‘soft phone’, named @sock1 after which we promptly ensure it was created (not_nil). This establishes that we have a valid connection between the tests and its requirements.</p>

<p>  Immediately after this we open a second FSR::CommandSocket to ‘blackbird’ for conducting the remainder of this feature’s Scenarios. We also populate a @uuid variable for use elsewhere in identifying related traffic, and connect the endpoint to freeswitch’s Music On Hold extension (MoH) 9664.</p>

<p>  The remainder of the code which is inside the 30.times do has us wait for up to 30 seconds to ensure that our call was actually processed. Items such as network delay, host OS issues, etc all play a part in how response times so we cover our butts a bit here to ensure the call actually got created.</p>

<p>  And finally, we terminal the call in order to show we have functional control over everything. This completes our primary test feature. Now that we know we have network connectivity, that our local testing environment is properly configured, that our truthiness can be trusted, and that we can originate/terminate calls, we can move forward into testing components of FreeSWITCH directly.</p>

<p>  That will be the focus of our next article covering 001_channel_can_dial_extensions.feature. The astute observer will notice a bit of overlap between 000 and 001 insofar as that we are testing the ability to connect to extensions, and we implement that same test twice, once in each feature. That is both on purpose, and due to the nature of establishing that you could actually do something with the established CommandSocket in the 000 feature.</p>

<p>  Thanks for reading!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[new-post]]></title>
    <link href="http://rubyists.github.com/fs_specs/blog/2012/02/20/new-post/"/>
    <updated>2012-02-20T22:18:00-05:00</updated>
    <id>http://rubyists.github.com/fs_specs/blog/2012/02/20/new-post</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Stage Fright Gone! Brief Synopsis of Goal]]></title>
    <link href="http://rubyists.github.com/fs_specs/blog/2012/02/15/stage-fright-gone-brief-synopsis-of-goal/"/>
    <updated>2012-02-15T20:53:00-05:00</updated>
    <id>http://rubyists.github.com/fs_specs/blog/2012/02/15/stage-fright-gone-brief-synopsis-of-goal</id>
    <content type="html"><![CDATA[<p>  What I was attempting to explain in the conferences was the subject of testing events within the context of channel and call state changes, and tracking those states for purposes of refining the granularity of both steps and EventSocket listener classes. I wasn&#8217;t .. clear .. (understatement) while explaining.</p>

<p>  So, thats what the next week of blog articles is about :) What we&#8217;re doing is taking Cucumber feature sets, augmented with RSpec for matchers, and using EventMachine, the FreeSWITCHeR ruby library, and a couple FreeSWITCH softswitches to:</p>

<p>  Open a Listener
  Hook into on_event with:
  add_event(:ALL){|event| handle_event(event) }</p>

<p> In handle_event(event) we datamatch against channel_state and call_state based on the thrown events using a hash of WANTED_STATE. Basically, right now I&#8217;m trying to map the events thrown for both channel_state and call_state changes, and the channel state sequences that get thrown per event.</p>

<p>  E.g channel has an associated call, that call could be hanging up, dialing another extension, calling into voicemail, et al. The channel has state for length of its call&#8217;s action. The call has state for the specific action done. Routing and call progression states also affect channel state.</p>

<p>  Channels have calls, both fire off events, events have names (CHANNEL_EXECUTE) and fire in specific order for a particular &#8216;action&#8217;, providing a mechanism for constant feedback on the current status of the channel and its associated call. The events fired are affected by the specific channel state e.g CS_HANGUP or CS_DESTROY and, internally, the call state e.g HANGUP or DESTROY.</p>

<p> Its the combination of these three status/state settings (event, channel, &#8216;call/action&#8217;) that reveal the inner workings of whats going on inside FreeSWITCH as it sees things, the channel, and the call. Grouping the channel&#8217;s event chain for a specific action on that channel, and then mapping the channel state changes that take place during that channel&#8217;s lifecycle, and the channel&#8217;s call lifecycle I believe provides value by exposing that internal coordination in such a way it can be readily and repeatably tested in a myriad of combinations.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[And They're Off! - The start of FS_SPECS]]></title>
    <link href="http://rubyists.github.com/fs_specs/blog/2012/02/15/and-theyre-off-the-start-of-fs-specs/"/>
    <updated>2012-02-15T19:52:00-05:00</updated>
    <id>http://rubyists.github.com/fs_specs/blog/2012/02/15/and-theyre-off-the-start-of-fs-specs</id>
    <content type="html"><![CDATA[<p>My name is Deryl R. Doucette. I&#8217;m the originator of, but only one of a team on, fs_specs which means [F]ree[S]witch [SPEC]ification[S]. The group over at The Rubyists, LLC. has been in on it from the get go. It was through conversations with TJ that this project was born. TJ has contributed great amounts of time, energy, and code. Ken Rice (SwK on freenode) has helped direct the flow of my inquiries, and provided key conceptual information.</p>

<p>So &#8220;What is &#8216;it&#8217;?&#8221;, you&#8217;re probably asking. FS_SPECs is a project to backfill testing into the FreeSWITCH Project utilizing the Ruby library FreeSWITCHeR as the interface to FreeSWITCH in an effort to enhance the stability, and usability, of both projects. The features and scenarios are written using Cucumber (which uses gherkin). We pull in RSpec for additional matchers. Everything else is Ruby. We are currently using Ruby 1.9.3p0, Cucumber 1.1.4, and RSpec 2.8.0. We use Bundler for gems management, which currently is 1.0.21. The Ruby environment is managed using RVM, and we utilize RVM&#8217;s per-project .rvmrc file capability.</p>

<p>This is the first post for fs_specs. I&#8217;m not usually sure what to say in a first post because its one that defines your outlook for that specific project. I&#8217;ve several outlooks, hopes, and thoughts on direction for this project. The first of which is that it be useful in what it does.</p>

<p>I&#8217;ve had the honor of speaking twice now during FreeSWITCH&#8217;s live weekly conference. I&#8217;ve come to realize that I do not, in any way shape or form, have the gift of &#8216;makin dah speech sounds&#8217;.</p>

<p>So, I figure I&#8217;ll fall back to my comfort zone which is writing. I like to write. I can express myself a bit better with the written word. Hopefully, along the way I&#8217;ll be able to express here what I was unable to in the conferences. Much of what I was hoping to point out with regards to testing events within the context of channel and call state changes never made it into the conversation. My brain went for a walk and decided not to take me with it. I was drawing complete blanks. :/ Not fun on life audio.</p>

<p>So, herein is where I&#8217;ll explain from top to bottom what I&#8217;m doing with fs_specs, urls for getting to the code, detailed explanations of the current Cucumber Features and Scenarios, and the exposed event&#8217;s content. On the code front, plaese be aware that I use the &#8216;master&#8217; branch as the &#8216;stable&#8217; branch. All development is done directly on, or in offshoots of, the &#8216;development&#8217; branch. Pulling master, which is the default, will always pull what is considered &#8216;Stable Release&#8217;.</p>

<p>There might be a bit of meandering as I gather my thoughts and order my information. Trust me, if you saw the editing that goes on <em>before</em> I hit the save button, you would quickly agree the saved is a much cleaner piece than originally written. <grin></p>

<p>Over th next few postings, I plan on taking apart the currently defined Features and their Scenarios on the master branch and explaining them here, along with the end-goal which might necessitate reworking some of the steps. I hope to use the explanations not only to educate on who, what, when, where, and why, but also because it might also serve to streamline my own thought processes thereby creating greater focus. One can hope!</p>
]]></content>
  </entry>
  
</feed>
