
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>FreeSWITCH And FreeSWITCHeR Ruby Library</title>
  <meta name="author" content="Deryl R. Doucette">

  
  <meta name="description" content="What Are We Doing Today? In this article, we’ll be discussing interacting with FreeSWITCH’s voicemail system using our &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://rubyists.github.com/fs_specs">
  <link href="/fs_specs/favicon.png" rel="icon">
  <link href="/fs_specs/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/fs_specs/javascripts/modernizr-2.0.js"></script>
  <script src="/fs_specs/javascripts/ender.js"></script>
  <script src="/fs_specs/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/fs_specs/atom.xml" rel="alternate" title="FreeSWITCH And FreeSWITCHeR Ruby Library" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h2><a href="/fs_specs/">FreeSWITCH And FreeSWITCHeR Ruby Library</a></h2>
  
  <h4>A Project for testing FreeSWITCH</h4>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/fs_specs/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:rubyists.github.com/fs_specs" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/fs_specs/">Blog</a></li>
  <li><a href="/fs_specs/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/fs_specs/blog/2012/02/22/interacting-with-voicemail-002-channel-can-interact-with-voicemail-feature/">Interacting With Voicemail</a></h2>
    
    
      <p class="meta">
        








  


<time datetime="2012-02-22T19:00:00-05:00" pubdate data-updated="true">Feb 22<span>nd</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>What Are We Doing Today?</h3>

<p>In this article, we’ll be discussing interacting with FreeSWITCH’s voicemail system using our <a href="https://github.com/rubyists/fs_specs/blob/master/features/002_channel_can_interact_with_voicemail.feature">002_channel_can_interact_with_voicemail</a> feature. This Feature will require that we write our own custom Listener class that we attach to the EventSocket’s <em>on_event()</em> method using our own customized <em>handle_event()</em> method.</p>

<h3>Feature -  <a href="https://github.com/rubyists/fs_specs/blob/master/features/002_channel_can_interact_with_voicemail.feature">002_channel_can_interact_with_voicemail.feature</a></h3>

<p>Here is the Feature itself.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='cucumber'><span class='line'><span class="nf">        Feature: Channel can interact with voicemail</span>
</span><span class='line'><span class="nf">     In order to utilize voicemail</span>
</span><span class='line'><span class="nf">     As a channel</span>
</span><span class='line'><span class="nf">     </span><span class="k">I </span><span class="nf">want to be able to log into, and use, the voicemail system</span>
</span><span class='line'>
</span><span class='line'><span class="nf">     </span><span class="k">Background:</span><span class="nf"></span>
</span><span class='line'><span class="k">      Given </span><span class="nf">I have </span><span class="s">2</span><span class="nf"> servers named blackbird.rubyists.com and tigershark.rubyists.com</span>
</span><span class='line'><span class="nf">     </span><span class="k">And </span><span class="nf">blackbird.rubyists.com is accessible via the Event Socket</span>
</span><span class='line'>
</span><span class='line'><span class="nf">     </span><span class="k">Scenario:</span><span class="nf"> Successfully log into voicemail using extension</span>
</span><span class='line'><span class="k">      And </span><span class="nf">I check voicemail for user </span><span class="s">1000</span><span class="nf"> with good password </span><span class="s">1000</span><span class="nf"></span>
</span><span class='line'><span class="nf">     </span><span class="k">Then </span><span class="nf">I should be logged into voicemail</span>
</span><span class='line'>
</span><span class='line'><span class="nf">     </span><span class="k">Scenario:</span><span class="nf"> Fail to log into voicemail using extension</span>
</span><span class='line'><span class="k">      And </span><span class="nf">I check voicemail for user </span><span class="s">1000</span><span class="nf"> with bad password </span><span class="s">1001</span><span class="nf"></span>
</span><span class='line'><span class="nf">     </span><span class="k">Then </span><span class="nf">I should be prompted to try again</span>
</span></code></pre></td></tr></table></div></figure>


<h3>What Exactly Does It Do? - <a href="https://github.com/rubyists/fs_specs/blob/master/features/step_definitions/steps.rb">steps.rb</a></h3>

<p>OK, here we go with the whirlwind ride of whats taking place within these Feature steps. The definitions of each of them are in the linked steps.rb file.</p>

<p>  As usual, we briefly describe in the Feature line, and expand upon immediately following, what the feature is for. We, again, hit the Background step which set up the connection for the remaining scenarios to use. That steps right into our first Scenario, “Successfully log into voicemail using extension”. In this Scenario, we check that we can log into voicemail for a specific extension, using the known password for that extension’s mailbox. This Scenario tests several sets of ideas.</p>

<p>It tests that we can:</p>

<pre><code>    * connect to the server
    * that it recognizes and sends us well formed data
    * that it recognizes well formed data we send it (e.g pressed keys)
    * that we recognize and identify the usage and response pattern freeswitch expects
    * that the expected pattern for interaction is seen in the data
    * that freeswitch responds correctly to our response. 
</code></pre>

<p>  The same is expected in the following Scenario, but for a negative test case. This ensures that we cover both states of recognition. Either we’re authenticated, or we’re not. If we are, use the system. If not, re-prompt and eventually drop.</p>

<p>Before we get into the specifics of the extension, let me explain what we’re going to be doing. We need a way to validate that we’re actually connecting to the voicemail system, and that we can react based upon the state changes we see as we move through the system. In this instance, freeswitch uses wav files to communicate. It plays specific wavs, in specific patterns and sub-patterns, that describe the various options available under the voicemail menu. We need some way to capture and use that information. Enter our custom class, the VmListener!</p>

<h3>The Code - What did we actually build? - <a href="https://github.com/rubyists/fs_specs/blob/master/features/step_definitions/vm_listener.rb">VmListener</a></h3>

<p>  If you look at the linked file, you&#8217;ll see that we define a class named VmListener which we attach to the freeswitch EventSocket.</p>

<figure class='code'><figcaption><span>VmListener Class</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'> <span class="k">class</span> <span class="nc">VmListener</span> <span class="o">&lt;</span> <span class="o">[</span><span class="no">FSL</span><span class="o">::</span><span class="no">Inbound</span><span class="o">]</span><span class="p">(</span><span class="n">https</span><span class="ss">:/</span><span class="o">/</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">rubyists</span><span class="o">/</span><span class="n">freeswitcher</span><span class="o">/</span><span class="n">blob</span><span class="o">/</span><span class="n">master</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">fsr</span><span class="o">/</span><span class="n">listener</span><span class="o">/</span><span class="n">inbound</span><span class="o">.</span><span class="n">rb</span><span class="p">)</span>
</span><span class='line'>  <span class="o">.</span><span class="n">.</span><span class="o">.</span>
</span><span class='line'>  <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>  You can find, over here, the definition for <a href="https://github.com/rubyists/freeswitcher/blob/master/lib/fsr/listener/inbound.rb">FSL::Inbound</a>. What is VmListener doing? In this case, if you review, you&#8217;ll see that we define the list of wav files that FreeSWITCH should play to us when we connect to the voicemail system.</p>

<figure class='code'><figcaption><span>Voicemail Wav File List</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'> <span class="no">PLAYBACK_FILES</span> <span class="o">=</span> <span class="o">[]</span>
</span><span class='line'>  <span class="no">SOUNDS</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">vm_enter_id</span><span class="p">:</span> <span class="s2">&quot;/var/lib/freeswitch/sounds/en/us/callie/voicemail/vm-enter_id.wav&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="n">vm_enter_pass</span><span class="p">:</span> <span class="s2">&quot;/var/lib/freeswitch/sounds/en/us/callie/voicemail/vm-enter_pass.wav&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="n">pound</span><span class="p">:</span> <span class="s2">&quot;file_string://ascii/35.wav&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="n">vm_abort</span><span class="p">:</span> <span class="s2">&quot;/var/lib/freeswitch/sounds/en/us/callie/voicemail/vm-abort.wav&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="n">vm_goodbye</span><span class="p">:</span> <span class="s2">&quot;/var/lib/freeswitch/sounds/en/us/callie/voicemail/vm-goodbye.wav&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="n">vm_press</span><span class="p">:</span> <span class="s2">&quot;/var/lib/freeswitch/sounds/en/us/callie/voicemail/vm-press.wav&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="n">vm_no_messages</span><span class="p">:</span> <span class="s2">&quot;/var/lib/freeswitch/sounds/en/us/callie/voicemail/vm-no_messages.wav&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="n">vm_fail</span><span class="p">:</span> <span class="s2">&quot;/var/lib/freeswitch/sounds/en/us/callie/voicemail/vm-fail_auth.wav&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="n">vm_has_messages</span><span class="p">:</span> <span class="s2">&quot;/var/lib/freeswitch/sounds/en/us/callie/voicemail/vm-you_have.wav&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>  This took me a bit of trial and error to find out as these are not listed anywhere that I found. (Anyone got a link I missed?) By playing with the connection and watching <em>fs_cli</em> output when the Listener connected, we got the list. Now, we redefine several methods in the class to do what we need done. In the first instance, we have the <em>initialize</em> method which sets up a slew of variables for us to make use of throughout the class. Next, we have <em>before_session</em>. All interaction with freeswitch is done via something called <em>Events</em>. Before freeswitch starts the actual session, we want to continue our setup for our needs. Here, we subscribe to the <em>PLAYBACK_STOP</em> event, which is thrown whenever a wav file completes its playtime. This allows us to <em>only</em> handle the specific event we need. Once a wav file finishes playing we know we can interact with the system. (Why else would it play us a file unless it wanted something from us, right?) For this particular use case, we want to make it so our custom handler, <em>handle_event</em>, is called.</p>

<p>  Next, we want to only deal with events that are specifically for us, so we tie in via the <em>post_init</em> method.</p>

<figure class='code'><figcaption><span>post_init</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'> <span class="k">def</span> <span class="nf">post_init</span>
</span><span class='line'>    <span class="vi">@spec_id</span> <span class="o">=</span> <span class="nb">rand</span><span class="p">(</span><span class="mi">100000000</span><span class="p">)</span><span class="o">.</span><span class="n">to_s</span>
</span><span class='line'>    <span class="n">orig</span> <span class="o">=</span> <span class="vi">@sock1</span><span class="o">.</span><span class="n">originate</span><span class="p">(</span><span class="n">target_options</span><span class="p">:</span> <span class="p">{</span><span class="n">origination_caller_id_number</span><span class="p">:</span> <span class="vi">@spec_id</span><span class="p">},</span> <span class="n">target</span><span class="p">:</span> <span class="s2">&quot;sofia/external/4000@</span><span class="si">#{</span><span class="vi">@server2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">endpoint</span><span class="p">:</span> <span class="s1">&#39;&amp;park&#39;</span><span class="p">)</span>
</span><span class='line'>    <span class="vi">@uuid</span> <span class="o">=</span> <span class="n">orig</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="ss">:api</span><span class="p">)</span><span class="o">[</span><span class="s1">&#39;body&#39;</span><span class="o">].</span><span class="n">split</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>
</span><span class='line'>    <span class="nb">warn</span> <span class="s2">&quot;UUID is </span><span class="si">#{</span><span class="vi">@uuid</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>    <span class="nb">warn</span> <span class="s2">&quot;spec_id is </span><span class="si">#{</span><span class="vi">@spec_id</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>  What this does is sets a spec_id for us. We use <em>rand()</em> to generate a ID for us, and then in the <em>@sock1.originate</em> we use it to set the <em>origination_caller_id_number</em> to match so we know anything with that caller ID was generated by our test(s), making it easier to isolate and track.</p>

<p>Now for a little bit of an explanation:</p>

<figure class='code'><figcaption><span>Socket Connection Code</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">orig</span> <span class="o">=</span> <span class="vi">@sock1</span><span class="o">.</span><span class="n">originate</span><span class="p">(</span><span class="n">target_options</span><span class="p">:</span> <span class="p">{</span><span class="n">origination_caller_id_number</span><span class="p">:</span> <span class="vi">@spec_id</span><span class="p">},</span> <span class="n">target</span><span class="p">:</span> <span class="s2">&quot;sofia/external/4000@</span><span class="si">#{</span><span class="vi">@server2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">endpoint</span><span class="p">:</span> <span class="s1">&#39;&amp;park&#39;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>This line of code calls the originate method on @sock1 which was created in the features/step_definitions/steps.rb file, specifically, on Line 11. Remember that @sock1 is an object created from the <a href="https://github.com/rubyists/freeswitcher/blob/master/lib/fsr/cmd/originate.rb">FSR::CommandSocket</a> class. That, in itself, is an overridden class of type Originate which is itself classed from Command. (As seen on Line 4 of the same file linked above.) This @sock1 object is what actually opens the connection to blackbird. If you remember, blackbird is our &#8216;Softphone&#8217; for these tests. It sets the caller ID to the spec_id, and then connects this leg to extension 4000 which is voicemail on the freeswitch server.</p>

<p>For those that missed where this was defined, here is the line of code.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="vi">@sock1</span> <span class="o">=</span> <span class="no">FSR</span><span class="o">::</span><span class="no">CommandSocket</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">server</span><span class="p">:</span> <span class="vi">@server1</span><span class="p">,</span> <span class="n">port</span><span class="p">:</span> <span class="mi">8021</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Next, we define a couple methods for our own use such as <em>enter_extension</em> and <em>enter_password</em>. These will push the DTMF tones for the keys involved in typing out the extension and password to the freeswitch server. Now we come to the meat of the class! (Aren&#8217;t you so glad?)</p>

<figure class='code'><figcaption><span>handle_event(event)</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">handle_event</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
</span><span class='line'>  <span class="k">return</span> <span class="k">unless</span> <span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">content</span><span class="o">[</span><span class="ss">:caller_caller_id_number</span><span class="o">]</span> <span class="o">==</span> <span class="vi">@spec_id</span><span class="p">)</span>
</span><span class='line'>  <span class="n">path</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">content</span><span class="o">[</span><span class="ss">:playback_file_path</span><span class="o">]</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">path</span> <span class="o">==</span> <span class="no">SOUNDS</span><span class="o">[</span><span class="ss">:pound</span><span class="o">]</span> <span class="ow">and</span> <span class="no">PLAYBACK_FILES</span><span class="o">.</span><span class="n">last</span> <span class="o">==</span> <span class="no">SOUNDS</span><span class="o">[</span><span class="ss">:vm_enter_id</span><span class="o">]</span><span class="p">)</span>
</span><span class='line'>    <span class="n">enter_extension</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">path</span> <span class="o">==</span> <span class="no">SOUNDS</span><span class="o">[</span><span class="ss">:pound</span><span class="o">]</span> <span class="ow">and</span> <span class="no">PLAYBACK_FILES</span><span class="o">.</span><span class="n">last</span> <span class="o">==</span> <span class="no">SOUNDS</span><span class="o">[</span><span class="ss">:vm_enter_pass</span><span class="o">]</span><span class="p">)</span>
</span><span class='line'>    <span class="n">enter_password</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="c1"># We call it logged in (or unsuccessful) when we hear any of these wavs</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">path</span> <span class="o">==</span> <span class="no">SOUNDS</span><span class="o">[</span><span class="ss">:vm_no_messages</span><span class="o">]</span> <span class="o">||</span> <span class="n">path</span> <span class="o">==</span> <span class="no">SOUNDS</span><span class="o">[</span><span class="ss">:vm_has_messages</span><span class="o">]</span> <span class="o">||</span> <span class="n">path</span> <span class="o">==</span> <span class="no">SOUNDS</span><span class="o">[</span><span class="ss">:vm_fail</span><span class="o">]</span><span class="p">)</span>
</span><span class='line'>    <span class="c1"># And hang up the call</span>
</span><span class='line'>    <span class="vi">@sock1</span><span class="o">.</span><span class="n">kill</span><span class="p">(</span><span class="vi">@uuid</span><span class="p">)</span><span class="o">.</span><span class="n">run</span>
</span><span class='line'>    <span class="c1"># Then stop the reactor</span>
</span><span class='line'>    <span class="no">EM</span><span class="o">.</span><span class="n">stop</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="no">PLAYBACK_FILES</span> <span class="o">&lt;&lt;</span> <span class="n">path</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>  Here, we first check to make sure that the caller ID matches our spec_id so we <em>only</em> deal with what our tests generated, and nothing more. Next, we use a temporary variable named path and set it to the full filepath as returned by freeswitch for the wav file its playing to us. We&#8217;ll do this over and over for each wav that comes in once PLAYBACK_STOP event has been fired for it. We know the combination of wav files we&#8217;re looking for from playing with <em>fs_cli</em> and watching the debug output. Here, we compare the files returned until we see that the last file played was <em>:vm_enter_id</em> and the current one is &#8216;#&#8217;. When we get that combination, in that particular order, we fire off our <em>enter_extension</em> method which calls <em>@sock1.send_uuid_dtmf</em> giving it both the UUID of the call (for identification), and the dtmf tones to send.</p>

<p>  In this instance, we&#8217;re sending the tones for the numbers 1000 which is our extension. This walks us right into our next check, which is for freeswitch prompting us for our password. We won&#8217;t get this if freeswitch never got our original dtmf tones. The fact that we even got the <em>:vm_enter_pass</em> wav file after the previous order tells us we successfully spoke with freeswitch. We continue to listen to more of the wav files offered up by freeswitch as they are our indicators of where we are in the call. If, after successfully logging in, we see the <em>:vm_no_messages</em>, <em>:vm_has_messages</em>, or <em>:vm_fail</em> we immediately hang up the call and stop the reactor. We then add the path we saw to the PLAYBACK_FILES array for future use.</p>

<p>Finally, we run the same Scenario again, but in the negative (by supplying an incorrect password) in order to ensure that we cover what happens if someone goofs their pass or extension.</p>

<h3>The Round Up - And In Closing…</h3>

<p>  I want to say a little something here about the Listener class. We purposefully create a new class for each Listener we want/need from VmListener named for whatever aspect we are trying to test. For instance, in our next feature we want to start culling lots of information from the Event freeswitch returns to us and put it in some sort of logical order what we&#8217;re looking for trying to identify, as closely as possible, the patterns exposed by FreeSWITCH for different events.
These patterns are non-negotiable. They are always exposed in specific order and for specific causes by freeswitch. By keying in on these patterns, and specifically testing for them, we are able to directly and correctly test freeswitch&#8217;s operations as well as that of FreeSWITCHeR.</p>

<h3>Up Next - A Look Ahead..</h3>

<p>Our next article will cover the exposed Event object from FreeSWITCH. For those that would like, please look ahead at <a href="https://github.com/rubyists/fs_specs/blob/master/features/003_can_retrieve_channel_information.feature">features/003_can_retrieve_channel_information.feature</a>. This feature is the last of our current &#8216;Core Features&#8217;, and was designed to expose the event object to you as much as possible so you can make decisions on what to test for, and so you can see what information you have available to you for that decision process.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/fs_specs/blog/2012/02/17/checking-out-extensions-001-channel-can-dial-extensions-feature/">Checking Out Extensions</a></h2>
    
    
      <p class="meta">
        








  


<time datetime="2012-02-17T13:53:00-05:00" pubdate data-updated="true">Feb 17<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Feature - <a href="https://github.com/rubyists/fs_specs/blob/master/features/001_channel_can_dial_extensions.feature">001_channel_can_dial_extensions.feature</a></h3>

<p>  As I said in the previous article, there is some overlap here. Note that I will be referring to features by their ordering number e.g 000. 000 also dials an extension, but in this feature we wanted to specifically isolate, and focus on, that distinct capability of dialling extensions.</p>

<p>  Here is the Feature itself. Remember, this is a testing framework targeting FreeSWITCH. So, we drive all of our actual code through the tests. We, in this instance, are using Cucumber to drive our entire framework so we start in the Feature itself.</p>

<figure class='code'><figcaption><span>features/001_channel_can_dial_extensions.feature</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='cucumber'><span class='line'><span class="nf">    Feature: A channel can dial an extension</span>
</span><span class='line'>
</span><span class='line'><span class="nf"> Once a UserAgent (X-Lite, PolyCom, another FS) can successfully connect to freeswitch, that UserAgent should be able to place a call to any known extension. The UserAgent should be connected to that extension. If that extension can not be reached, or the extension is not known, then the UserAgent should be notified of both the fact of the failure, and the type of the failure.</span>
</span><span class='line'>
</span><span class='line'><span class="nf"> </span><span class="k">Background:</span><span class="nf"></span>
</span><span class='line'><span class="nf">   Given I have 2 servers named blackbird.rubyists.com and tigershark.rubyists.com</span>
</span><span class='line'><span class="nf">   And blackbird.rubyists.com is accessible via the Event Socket</span>
</span><span class='line'>
</span><span class='line'><span class="nf">   Scenario:</span>
</span><span class='line'><span class="nf">     When I dial extension “1000” on tigershark.rubyists.com</span>
</span><span class='line'><span class="nf">     Then I should be connected to that extension</span>
</span><span class='line'><span class="nf">     And I should be able to terminate the call</span>
</span><span class='line'>
</span><span class='line'><span class="nf">   Scenario:</span>
</span><span class='line'><span class="nf">     When I dial unknown extension “1020”</span>
</span><span class='line'><span class="nf">     Then I should be notified the call failed</span>
</span><span class='line'><span class="nf">     And I should receive call failure type “NO_USER_RESPONSE”</span>
</span></code></pre></td></tr></table></div></figure>


<p>  You can see we’ve defined the Feature title explaining what we’re doing. Immediately after we’ve added a deeper explanation of what we’re trying to do. These expanded comments do actually help in the documentation, so I’ll be using them quite a bit going forward. Feel free to correct my technical orderings or something I’ve totally not grokked!</p>

<p>  As mentioned previously, the Background will be the same for every test going forward as that block defines, and creates, the actual EventSockets we’ll be working with in each Feature set. In this instance we’re sending information over the socket using blackbird to talk to tigershark here. Only when the entire Feature has finished will it be torn down.</p>

<p>  Our first Scenario in the Feature dials a specific extension, ‘1000’, shooting the request to freeswitch tigershark, which again, is the system we’re testing. This is done by the following step definition:</p>

<figure class='code'><figcaption><span>features/step_definitions/steps.rb</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cucumber'><span class='line'><span class="nf">    </span><span class="k">When </span><span class="nf">/^I dial extension “([^”]*)” on ([\w.]+)$/ do |known_extension, server|</span>
</span><span class='line'><span class="nf">   orig = </span><span class="nt">@sock2.originate(target:</span><span class="nf"> ‘sofia/external/%s</span><span class="nt">@%s’</span><span class="nf"> % [known_extension, </span><span class="nt">@server2],</span><span class="nf"> endpoint:</span>
</span><span class='line'><span class="nf">                                            “&amp;transfer(‘</span><span class="s">3000</span><span class="nf"> XML default’)”)</span>
</span><span class='line'><span class="nf">   orig.should_not be_nil</span>
</span><span class='line'><span class="nf">   </span><span class="nt">@resp</span><span class="nf"> = orig.run(:api)</span>
</span><span class='line'><span class="nf">   fail “Response does not contain OK” unless (</span><span class="nt">@resp[“body”].match</span><span class="nf"> /^\+OK \w{</span><span class="s">8</span><span class="nf">}-(?:\w{</span><span class="s">4</span><span class="nf">}-){</span><span class="s">3</span><span class="nf">}\w{</span><span class="s">12</span><span class="nf">}$/)</span>
</span><span class='line'><span class="nf"> end</span>
</span></code></pre></td></tr></table></div></figure>


<p>  We pass originate() the extension we’re trying to hit through the captured step variable to known_extension and using that to populate which extension we want, and we immediately transfer it to extension 3000 in the default XML dial plan, which is a Conference extension. We then immediately check that this took place by testing orig is not nil. It will only be nil if the originate call failed. We double check by checking the response body for +OK, as seen in the .match() statement’s regular expression. If it doesn’t match, we hard fail the test.</p>

<p>  We passed, good. Its on to the next step which is verifying that we were, in fact, connected to that extension. That is accomplished through the step definition here:</p>

<figure class='code'><figcaption><span>features/step_definitions/steps.rb</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cucumber'><span class='line'><span class="nf">    </span><span class="k">Then </span><span class="nf">/^I should be connected to that extension$/ do</span>
</span><span class='line'><span class="nf">   message, </span><span class="nt">@uuid</span><span class="nf"> = </span><span class="nt">@resp[&quot;body&quot;].split(&quot;</span><span class="nf"> &quot;</span><span class="s">)</span>
</span><span class='line'><span class="s">    fail </span><span class="nf">&quot;No UUID found&quot;</span><span class="s"> unless message == &#39;+OK&#39;</span>
</span><span class='line'><span class="s">  end</span>
</span></code></pre></td></tr></table></div></figure>


<p>  In this snippet, we split up the returned response body on spaces, and then set both @uuid which will be used further along in the Feature set, and message. Finally, because we know we won’t get a uuid unless we got a valid response back, we check that message equals +OK. Now we know that @uuid is populated correctly without checking it directly. For stricter checking, we might even want to revisit that and add an explicit check on @uuid.</p>

<p>  We’re all done with this Scenario, except for one thing. We need to terminate the call itself, if for no other reason than to show we can from within the tests. That is accomplished via:</p>

<figure class='code'><figcaption><span>features/step_definitions/steps.rb</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='cucumber'><span class='line'><span class="nf">    </span><span class="k">Then </span><span class="nf">/^I should be able to terminate the call$/ do</span>
</span><span class='line'><span class="nf">   </span><span class="nt">@uuid.should_not</span><span class="nf"> be_nil</span>
</span><span class='line'><span class="nf">   resp = </span><span class="nt">@sock2.kill(@uuid).run(:api)</span><span class="nf"></span>
</span><span class='line'><span class="nf">   resp[“body”].should match(/^\+OK/)</span>
</span><span class='line'><span class="nf">   </span><span class="s">30.</span><span class="nf">times do</span>
</span><span class='line'><span class="nf">     sleep </span><span class="s">0.1</span><span class="nf"></span>
</span><span class='line'><span class="nf">     break unless </span><span class="nt">@sock2.calls.run.detect</span><span class="nf"> {</span><span class="k"> |</span><span class="s">c</span><span class="k">|</span><span class="s"> c.uuid == @uuid }</span>
</span><span class='line'><span class="s">    end</span>
</span><span class='line'><span class="s">    </span><span class="c"># Make sure there are no calls left still dangling</span><span class="s"></span>
</span><span class='line'><span class="s">    @sock2.calls.run.detect {</span><span class="k"> |</span><span class="s">c</span><span class="k">|</span><span class="s"> c.uuid == @uuid }.should be_nil</span>
</span><span class='line'><span class="s">  end</span>
</span></code></pre></td></tr></table></div></figure>


<p>  Here, we check that @uuid set in the previous step survived into this one and that its not nil. That would be bad! Since we have a valid @uuid, we pass that to the socket and call kill() using the synchronous API call. We do this so that it doesn’t get backgrounded on us, and we get an actual response back. That leads us right into the next line which checks the response body for +OK again.</p>

<p>  Next, for the count of 30 seconds we sleep for 0.1s calling detect on the uuid so we can see when it disappears. When it disappears from the call list on tigershark, we break out of the loop. We use 0.1 so we can exit the fastest possible out of the loop once we know the call has been torn down and destroyed. And just to be sure, just before we exit the step all together, we check once more via detect on our way out the door.</p>

<p>  This moves us into our next Scenario where we check to see what happens when we attempt to call an extension that isn’t configured, or otherwise doesn’t exist. The snippets for that are as follows:</p>

<figure class='code'><figcaption><span>features/step_definitions/steps.rb</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='cucumber'><span class='line'><span class="nf">    </span><span class="k">When </span><span class="nf">/^I dial unknown extension “([^”]*)”$/ do | unknown_extension|</span>
</span><span class='line'><span class="nf">   orig = </span><span class="nt">@sock2.originate(target:</span><span class="nf"> ‘sofia/external/%s</span><span class="nt">@%s’</span><span class="nf"> % [unknown_extension, </span><span class="nt">@server2],</span><span class="nf"></span>
</span><span class='line'><span class="nf">   endpoint: “&amp;transfer(‘</span><span class="s">3000</span><span class="nf"> XML default’)”)</span>
</span><span class='line'><span class="nf">   </span><span class="nt">@resp</span><span class="nf"> = orig.run(:api)</span>
</span><span class='line'><span class="nf">   </span><span class="nt">@resp[“body”].should</span><span class="nf"> match(/^-ERR/)</span>
</span><span class='line'><span class="nf"> end</span>
</span><span class='line'>
</span><span class='line'><span class="nf"> </span><span class="k">Then </span><span class="nf">/^I should be notified the call failed$/ do</span>
</span><span class='line'><span class="nf">   status, </span><span class="nt">@message</span><span class="nf"> = </span><span class="nt">@resp[“body”].split(“</span><span class="nf"> “)</span>
</span><span class='line'><span class="nf">   status.should match(‘-ERR’)</span>
</span><span class='line'><span class="nf"> end</span>
</span><span class='line'>
</span><span class='line'><span class="nf"> </span><span class="k">Then </span><span class="nf">/^I should receive call failure type “([^”]*)”$/ do |failure_type|</span>
</span><span class='line'><span class="nf">   </span><span class="nt">@message.should</span><span class="nf"> match(“</span><span class="c">#{failure_type}”)</span><span class="nf"></span>
</span><span class='line'><span class="nf"> end</span>
</span></code></pre></td></tr></table></div></figure>


<p>  Running fairly quickly through the steps, we reuse the guts of When I dial extension here because we have to do the same thing as we did in that step, but in this case it will be used in the exact opposite. Same steps opposite results, as intended, to show both states: Success, and Failure. Here you can see that we check for -ERR rather than +OK in the other step for both.</p>

<p>  Now, we again parse message here, in which case we look for the specific failure type that was returned. In this instance the expected return type for a failed call is NO_USER_RESPONSE. I did that really fast run-through because its the same as for dialling a known extension, except in the negative.</p>

<p>The Code - What did we actually build?</p>

<p>  I realize, at this point, people might be asking themselves if its worth writing test features and step definitions for the little bit of code that is actually driven out by that process. Here are the step lines, minus their closing ‘end’, and the lines of code we generated as a result.</p>

<figure class='code'><figcaption><span>Feature Steps</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cucumber'><span class='line'><span class="nf">    Given /^I have </span><span class="s">2</span><span class="nf"> servers named ([\w.]+) and ([\w.]+)$/ do</span><span class="k"> |</span><span class="s">server1, server2</span><span class="k">|</span><span class="s"></span>
</span><span class='line'><span class="s">    Given /^([\w.]+) is accessible via the Event Socket$/ do</span><span class="k"> |</span><span class="s">es_server</span><span class="k">|</span><span class="s"></span>
</span><span class='line'><span class="s">    When /^I dial extension &quot;([^&quot;]*)&quot; on ([\w.]+)$/ do</span><span class="k"> |</span><span class="s">known_extension, server</span><span class="k">|</span><span class="s"></span>
</span><span class='line'><span class="s">    Then /^I should be connected to that extension$/ do</span>
</span><span class='line'><span class="s">    Then /^I should be able to terminate the call$/ do</span>
</span><span class='line'><span class="s">    When /^I dial unknown extension &quot;([^&quot;]*)&quot;$/ do</span><span class="k"> |</span><span class="s"> unknown_extension</span><span class="k">|</span><span class="s"></span>
</span><span class='line'><span class="s">    Then /^I should be notified the call failed$/ do</span>
</span><span class='line'><span class="s">    Then /^I should recieve call failure type &quot;([^&quot;]*)&quot;$/ do</span><span class="k"> |</span><span class="s">failure_type</span><span class="k">|</span><span class="s"></span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>Code Lines Driven Out</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'> <span class="vi">@server1</span><span class="p">,</span> <span class="vi">@server2</span> <span class="o">=</span> <span class="n">server1</span><span class="p">,</span> <span class="n">server2</span>
</span><span class='line'>  <span class="vi">@sock1</span> <span class="o">=</span> <span class="no">FSR</span><span class="o">::</span><span class="no">CommandSocket</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">server</span><span class="p">:</span> <span class="vi">@server1</span><span class="p">,</span> <span class="n">port</span><span class="p">:</span> <span class="mi">8021</span><span class="p">)</span>
</span><span class='line'>  <span class="vi">@played_files</span> <span class="o">=</span> <span class="o">[]</span>
</span><span class='line'>  <span class="vi">@sock2</span> <span class="o">=</span> <span class="no">FSR</span><span class="o">::</span><span class="no">CommandSocket</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">server</span><span class="p">:</span> <span class="vi">@server1</span><span class="p">)</span>
</span><span class='line'>  <span class="vi">@sock2</span><span class="o">.</span><span class="n">should_not</span> <span class="n">be_nil</span>
</span><span class='line'>  <span class="n">orig</span> <span class="o">=</span> <span class="vi">@sock2</span><span class="o">.</span><span class="n">originate</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="err">‘</span><span class="n">sofia</span><span class="o">/</span><span class="n">external</span><span class="o">/</span><span class="sx">%s@%s’ % [known_extension, @</span><span class="n">server2</span><span class="o">]</span><span class="p">,</span> <span class="n">endpoint</span><span class="p">:</span> <span class="err">“</span><span class="o">&amp;</span><span class="n">transfer</span><span class="p">(</span><span class="err">‘</span><span class="mi">3000</span> <span class="no">XML</span> <span class="n">default</span><span class="err">’</span><span class="p">)</span><span class="err">”</span><span class="p">)</span>
</span><span class='line'>  <span class="n">orig</span><span class="o">.</span><span class="n">should_not</span> <span class="n">be_nil</span>
</span><span class='line'>  <span class="vi">@resp</span> <span class="o">=</span> <span class="n">orig</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="ss">:api</span><span class="p">)</span>
</span><span class='line'>  <span class="nb">fail</span> <span class="err">“</span><span class="no">Response</span> <span class="n">does</span> <span class="ow">not</span> <span class="n">contain</span> <span class="no">OK</span><span class="err">”</span> <span class="k">unless</span> <span class="p">(</span><span class="vi">@resp</span><span class="o">[</span><span class="err">“</span><span class="n">body</span><span class="err">”</span><span class="o">].</span><span class="n">match</span><span class="sr"> /^\+OK \w{8}-(?:\w{4}-){3}\w{12}$/</span><span class="p">)</span>
</span><span class='line'>  <span class="n">message</span><span class="p">,</span> <span class="vi">@uuid</span> <span class="o">=</span> <span class="vi">@resp</span><span class="o">[</span><span class="err">“</span><span class="n">body</span><span class="err">”</span><span class="o">].</span><span class="n">split</span><span class="p">(</span><span class="err">“</span> <span class="err">“</span><span class="p">)</span>
</span><span class='line'>  <span class="nb">fail</span> <span class="err">“</span><span class="no">No</span> <span class="no">UUID</span> <span class="n">found</span><span class="err">”</span> <span class="k">unless</span> <span class="n">message</span> <span class="o">==</span> <span class="err">‘</span><span class="o">+</span><span class="no">OK</span><span class="err">’</span>
</span><span class='line'>  <span class="vi">@uuid</span><span class="o">.</span><span class="n">should_not</span> <span class="n">be_nil</span>
</span><span class='line'>  <span class="n">resp</span> <span class="o">=</span> <span class="vi">@sock2</span><span class="o">.</span><span class="n">kill</span><span class="p">(</span><span class="vi">@uuid</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="ss">:api</span><span class="p">)</span>
</span><span class='line'>  <span class="n">resp</span><span class="o">[</span><span class="err">“</span><span class="n">body</span><span class="err">”</span><span class="o">].</span><span class="n">should</span> <span class="n">match</span><span class="p">(</span><span class="sr">/^\+OK/</span><span class="p">)</span>
</span><span class='line'>  <span class="mi">30</span><span class="o">.</span><span class="n">times</span> <span class="k">do</span>
</span><span class='line'>  <span class="err"> </span> <span class="nb">sleep</span> <span class="mi">0</span><span class="o">.</span><span class="mi">1</span>
</span><span class='line'>  <span class="err">  </span><span class="k">break</span> <span class="k">unless</span> <span class="vi">@sock2</span><span class="o">.</span><span class="n">calls</span><span class="o">.</span><span class="n">run</span><span class="o">.</span><span class="n">detect</span> <span class="p">{</span> <span class="o">|</span><span class="n">c</span><span class="o">|</span> <span class="n">c</span><span class="o">.</span><span class="n">uuid</span> <span class="o">==</span> <span class="vi">@uuid</span> <span class="p">}</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="vi">@sock2</span><span class="o">.</span><span class="n">calls</span><span class="o">.</span><span class="n">run</span><span class="o">.</span><span class="n">detect</span> <span class="p">{</span> <span class="o">|</span><span class="n">c</span><span class="o">|</span> <span class="n">c</span><span class="o">.</span><span class="n">uuid</span> <span class="o">==</span> <span class="vi">@uuid</span> <span class="p">}</span><span class="o">.</span><span class="n">should</span> <span class="n">be_nil</span>
</span><span class='line'>  <span class="n">orig</span> <span class="o">=</span> <span class="vi">@sock2</span><span class="o">.</span><span class="n">originate</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="err">‘</span><span class="n">sofia</span><span class="o">/</span><span class="n">external</span><span class="o">/</span><span class="sx">%s@%s’ % [unknown_extension, @</span><span class="n">server2</span><span class="o">]</span><span class="p">,</span>
</span><span class='line'>  <span class="n">endpoint</span><span class="p">:</span> <span class="err">“</span><span class="o">&amp;</span><span class="n">transfer</span><span class="p">(</span><span class="err">‘</span><span class="mi">3000</span> <span class="no">XML</span> <span class="n">default</span><span class="err">’</span><span class="p">)</span><span class="err">”</span><span class="p">)</span>
</span><span class='line'>  <span class="vi">@resp</span> <span class="o">=</span> <span class="n">orig</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="ss">:api</span><span class="p">)</span>
</span><span class='line'>  <span class="vi">@resp</span><span class="o">[</span><span class="err">“</span><span class="n">body</span><span class="err">”</span><span class="o">].</span><span class="n">should</span> <span class="n">match</span><span class="p">(</span><span class="sr">/^-ERR/</span><span class="p">)</span>
</span><span class='line'>  <span class="n">status</span><span class="p">,</span> <span class="vi">@message</span> <span class="o">=</span> <span class="vi">@resp</span><span class="o">[</span><span class="err">“</span><span class="n">body</span><span class="err">”</span><span class="o">].</span><span class="n">split</span><span class="p">(</span><span class="err">“</span> <span class="err">“</span><span class="p">)</span>
</span><span class='line'>  <span class="n">status</span><span class="o">.</span><span class="n">should</span> <span class="n">match</span><span class="p">(</span><span class="err">‘</span><span class="o">-</span><span class="no">ERR</span><span class="err">’</span><span class="p">)</span>
</span><span class='line'>  <span class="vi">@message</span><span class="o">.</span><span class="n">should</span> <span class="n">match</span><span class="p">(</span><span class="err">“</span><span class="c1">#{failure_type}”)</span>
</span></code></pre></td></tr></table></div></figure>


<p>  <em><strong>Total Step Lines: 8 | Total Code Lines: 25 | Code To Step Ratio: 3:1</strong></em></p>

<p>  Not bad, we are averaging 3 lines of code being described by 1 step line. Or, if you prefer, we are averaging 3 lines of code to pass 1 step. To get back on the beaten path, we have completed the contents of 001 and proven out our Feature. So, far it looks like things are progressing right along.</p>

<p>  Our next article will add more to the pot because we’ll be adding in our first Listener class for handling events on the Listener we create and attach to the EventSocket. Anyone who wants a heads up can look over here.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/fs_specs/blog/2012/02/16/anatomy-of-an-fs-specs-feature-set-000-phone-infrastructure-feature/">Anatomy of an FS_SPECS Feature Set</a></h2>
    
    
      <p class="meta">
        








  


<time datetime="2012-02-16T14:44:00-05:00" pubdate data-updated="true">Feb 16<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>FS_SPECS Stable Branch - <a href="https://github.com/rubyists/fs_specs">master</a></h3>

<p>As I stated earlier, our ‘master’ branch on <a href="https://github.com">GitHub</a> is the ‘Stable Release’ branch for fs_specs. As of today’s date, we currently have 4 Features that test different aspects of FreeSWITCH through FreeSWITCHeR. They are:</p>

<ul>
<li>000_phone_infrastructure.feature</li>
<li>001_channel_can_dial_extensions.feature</li>
<li>002_channel_can_interact_with_voicemail.feature</li>
<li>003_can_retrieve_channel_information.feature</li>
</ul>


<p>Over the next few articles I’ll be diving into the anatomy of each feature, the attendant steps, and the <em>FSL::Inbound</em> xxListener classes for each.</p>

<h3>Feature - <a href="https://github.com/rubyists/fs_specs/blob/master/features/000_phone_infrastructure.feature">000_phone_infrastructure.feature</a></h3>

<figure class='code'><figcaption><span>features/000_phone_infrastructure.feature</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='cucumber'><span class='line'><span class="k">Feature:</span><span class="nf"> Establish that phone infrastructure is working  </span>
</span><span class='line'><span class="nf">If we have 2 properly configured freeswitch servers, </span>
</span><span class='line'><span class="nf">   we want to ensure we can make a connection between the 2 of them,</span>
</span><span class='line'><span class="nf">   and properly terminate that connection.</span>
</span><span class='line'>
</span><span class='line'><span class="nf">   </span><span class="k">Background:</span><span class="nf"> </span>
</span><span class='line'><span class="k">   Given </span><span class="nf">I have </span><span class="s">2</span><span class="nf"> servers named blackbird.rubyists.com and tigershark.rubyists.com</span>
</span><span class='line'><span class="nf">   </span><span class="k">And </span><span class="nf">blackbird.rubyists.com is accessible via the Event Socket</span>
</span><span class='line'>
</span><span class='line'><span class="nf">   </span><span class="k">Scenario:</span><span class="nf"> Show that True and False express correctly, and exactly, with should and should_not</span>
</span><span class='line'><span class="k">   Then </span><span class="nf">true.should == true</span>
</span><span class='line'><span class="nf">   </span><span class="k">And </span><span class="nf"> false.should != true</span>
</span><span class='line'>
</span><span class='line'><span class="nf">   </span><span class="k">Scenario:</span><span class="nf"> </span>
</span><span class='line'><span class="k">   When </span><span class="nf">I make a phone call</span>
</span><span class='line'><span class="nf">   </span><span class="k">Then </span><span class="nf">I should be able to terminate the call</span>
</span></code></pre></td></tr></table></div></figure>


<p>   This feature is the key to the entire set, both existing and those to come. The reason for this is the features job is solely to establish that you have a working configuration for running the rest of the features. If this particular feature fails nothing else will work.</p>

<p>   To see what this feature is actually doing, lets open up the associated <a href="https://github.com/rubyists/fs_specs/blob/master/features/step_definitions/steps.rb">‘steps.rb’</a> file and look for the matchers that comprise each step of each Scenario as they go along. Background in each feature file sets up stuff we need to make it all work and keeps it existing for each Scenario in the feature rather than tearing it all down in-between each one.</p>

<p>   As we can see from the feature title, this feature set establishes that the phone infrastructure for all remaining tests can be found and is correctly configured. In the Background segment’s Given line, we are checking to ensure we can access both machines listed. The first server listed (blackbird.rubyists.com) is a freeswitch that is being used basically as nothing more than a soft phone. The second server listed (tigershark.rubyists.com) is the actual freeswitch being tested. The And line ensures that we can talk to the soft phone (blackbird) via freeswitch’s EventSocket.</p>

<p>   In the first Scenario, we establish the validity of both ‘true’ and ‘false’ values which establishes the credibility of all remaining tests. If ‘true’ and ‘false’ really aren’t what values they say they are, not a chance in the Universe you can be positive any positive or negative results are valid. Since this is our initialization feature, we put it as the first Scenario.</p>

<p>   In the final Scenario, we concretely establish our baseline configuration by ensuring we can originate a call to freeswitch, and that we can, in turn, terminate that call. The steps which comprise this Feature are as follows:</p>

<figure class='code'><figcaption><span>Feature with associated Steps logic</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
</pre></td><td class='code'><pre><code class='cucumber'><span class='line'><span class="nf">   </span><span class="k">Background:</span><span class="nf"> </span>
</span><span class='line'><span class="k">   Given </span><span class="nf">/^I have </span><span class="s">2</span><span class="nf"> servers named ([\w.]+) and ([\w.]+)$/ do |server</span><span class="s">1</span><span class="nf">, server</span><span class="s">2</span><span class="nf">|</span>
</span><span class='line'><span class="nf">  </span><span class="nt">@server1,</span><span class="nf"> </span><span class="nt">@server2</span><span class="nf"> = server</span><span class="s">1</span><span class="nf">, server</span><span class="s">2</span><span class="nf"></span>
</span><span class='line'><span class="nt">@sock1</span><span class="nf"> = FSR::CommandSocket.new(server: </span><span class="nt">@server1,</span><span class="nf"> port: </span><span class="s">8021</span><span class="nf">)</span>
</span><span class='line'><span class="nf">  </span><span class="nt">@played_files</span><span class="nf"> = []</span>
</span><span class='line'><span class="nf">  end</span>
</span><span class='line'>
</span><span class='line'><span class="nf">  </span><span class="k">Given </span><span class="nf">/^([\w.]+) is accessible via the Event Socket$/ do |es_server|</span>
</span><span class='line'><span class="nt">@sock2</span><span class="nf"> = FSR::CommandSocket.new(server: </span><span class="nt">@server1)</span><span class="nf"></span>
</span><span class='line'><span class="nf">  </span><span class="nt">@sock2.should_not</span><span class="nf"> be_nil</span>
</span><span class='line'><span class="nf">  end</span>
</span><span class='line'>
</span><span class='line'><span class="nf">  </span><span class="k">Scenario:</span><span class="nf"></span>
</span><span class='line'><span class="k">  Then </span><span class="nf">/^true.should == true$/ do</span>
</span><span class='line'><span class="nf">  true.should == true</span>
</span><span class='line'><span class="nf">  end</span>
</span><span class='line'>
</span><span class='line'><span class="nf">  </span><span class="k">Then </span><span class="nf">/^false.should != true$/ do</span>
</span><span class='line'><span class="nf">  false.should_not == true</span>
</span><span class='line'><span class="nf">  end</span>
</span><span class='line'>
</span><span class='line'><span class="nf">  </span><span class="k">Scenario:</span><span class="nf"></span>
</span><span class='line'><span class="k">  When </span><span class="nf">/^I make a phone call$/ do</span>
</span><span class='line'><span class="nf">orig = </span><span class="nt">@sock2.originate(target:</span><span class="nf"> “sofia/external/</span><span class="s">3000</span><span class="nt">@#{@server2}”,</span><span class="nf"> endpoint: ‘&amp;transfer(</span><span class="s">9664</span><span class="nf">)’)</span>
</span><span class='line'><span class="nf">  </span><span class="nt">@uuid</span><span class="nf"> = orig.run(:api)[‘body’].split[</span><span class="s">1</span><span class="nf">]</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Due to asynchronous nature of the entire method chain</span><span class="nf"></span>
</span><span class='line'><span class="c"># which involves network stack, call plans, etc..</span><span class="nf"></span>
</span><span class='line'><span class="c"># We sleep long enough for the call creations have been handled _throughout_ the stack.</span><span class="nf"></span>
</span><span class='line'><span class="c"># We limit our sleep times to &lt; 1s in order to wait the last amount of time,</span><span class="nf"></span>
</span><span class='line'><span class="c"># and include additional checks oxide the sleep to limit wait time further.</span><span class="nf"></span>
</span><span class='line'><span class="nf">  </span><span class="s">30.</span><span class="nf">times do</span>
</span><span class='line'><span class="nf">  sleep </span><span class="s">0.1</span><span class="nf"></span>
</span><span class='line'><span class="nf">  break if </span><span class="nt">@sock2.calls.run.any?{|call|</span><span class="nf"> call.uuid == </span><span class="nt">@uuid</span><span class="nf"> }</span>
</span><span class='line'><span class="nf">  end</span>
</span><span class='line'><span class="nf">  our_call = </span><span class="nt">@sock2.calls.run.detect</span><span class="nf"> {</span><span class="k"> |</span><span class="s">call</span><span class="k">|</span><span class="s"> call.uuid == @uuid }</span>
</span><span class='line'><span class="s">  fail “No Call Exists!” unless our_call and our_call.uuid == @uuid</span>
</span><span class='line'><span class="s">  end</span>
</span><span class='line'>
</span><span class='line'><span class="s">  Then /^I should be able to terminate the call$/ do</span>
</span><span class='line'><span class="s">  @uuid.should_not be_nil</span>
</span><span class='line'>
</span><span class='line'><span class="s">resp = @sock2.kill(@uuid).run(:api)</span>
</span><span class='line'>
</span><span class='line'><span class="s">resp[“body”].should match(/^\+OK/)</span>
</span><span class='line'>
</span><span class='line'><span class="s">  30.times do</span>
</span><span class='line'><span class="s">  sleep 0.1</span>
</span><span class='line'><span class="s">  break unless @sock2.calls.run.detect {</span><span class="k"> |</span><span class="s">c</span><span class="k">|</span><span class="s"> c.uuid == @uuid }</span>
</span><span class='line'><span class="s">  end</span>
</span><span class='line'><span class="c"># Make sure there are no calls left still dangling</span><span class="s"></span>
</span><span class='line'><span class="s">  @sock2.calls.run.detect {</span><span class="k"> |</span><span class="s">c</span><span class="k">|</span><span class="s"> c.uuid == @uuid }.should be_nil</span>
</span><span class='line'><span class="s">  end</span>
</span></code></pre></td></tr></table></div></figure>


<p>  To distill that all down, in the Background we define several ivars for use elsewhere in the Feature, such as <em>@server1</em>, <em>@server2</em>, and use them to open a <em>FSR::CommandSocket</em> to ‘blackbird’, our ‘soft phone’, named @sock1 after which we promptly ensure it was created (not_nil). This establishes that we have a valid connection between the tests and its requirements.</p>

<p>  Immediately after this we open a second <em>FSR::CommandSocket</em> to ‘blackbird’ for conducting the remainder of this feature’s Scenarios. We also populate a <em>@uuid</em> variable for use elsewhere in identifying related traffic, and connect the endpoint to freeswitch’s Music On Hold extension (MoH) 9664.</p>

<p>  The remainder of the code which is inside the 30.times do has us wait for up to 30 seconds to ensure that our call was actually processed. Items such as network delay, host OS issues, etc all play a part in how response times so we cover our butts a bit here to ensure the call actually got created.</p>

<p>  And finally, we terminal the call in order to show we have functional control over everything. This completes our primary test feature. Now that we know we have network connectivity, that our local testing environment is properly configured, that our truthiness can be trusted, and that we can originate/terminate calls, we can move forward into testing components of FreeSWITCH directly.</p>

<p>  That will be the focus of our next article covering <a href="https://github.com/rubyists/fs_specs/blob/master/features/001_channel_can_dial_extensions.feature">001_channel_can_dial_extensions.feature</a>. The astute observer will notice a bit of overlap between 000 and 001 insofar as that we are testing the ability to connect to extensions, and we implement that same test twice, once in each feature. That is both on purpose, and due to the nature of establishing that you could actually do something with the established CommandSocket in the 000 feature.</p>

<p>  Thanks for reading!</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/fs_specs/blog/2012/02/15/stage-fright-gone-brief-synopsis-of-goal/">Stage Fright Gone! Brief Synopsis of Goal</a></h2>
    
    
      <p class="meta">
        








  


<time datetime="2012-02-15T20:53:00-05:00" pubdate data-updated="true">Feb 15<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>  What I was attempting to explain in the conferences was the subject of testing events within the context of channel and call state changes, and tracking those states for purposes of refining the granularity of both steps and EventSocket listener classes. I wasn&#8217;t .. clear .. (understatement) while explaining.</p>

<p>  So, thats what the next week of blog articles is about :) What we&#8217;re doing is taking Cucumber feature sets, augmented with RSpec for matchers, and using EventMachine, the FreeSWITCHeR ruby library, and a couple FreeSWITCH soft-switches to:</p>

<p>  Open a Listener Hook into on_event with:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="n">add_event</span><span class="p">(</span><span class="ss">:ALL</span><span class="p">){</span> <span class="o">|</span><span class="n">event</span><span class="o">|</span> <span class="n">handle_event</span><span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p> In <em>handle_event(event)</em>, we data match against channel_state and call_state based on the thrown events using a hash of <em>WANTED_STATE</em>. Basically, right now I&#8217;m trying to map the events thrown for both channel_state and call_state changes, and the channel state sequences that get thrown per event.</p>

<p>  E.g channel has an associated call, that call could be hanging up, dialling another extension, calling into voicemail, et al. The channel has state for length of its call&#8217;s action. The call has state for the specific action done. Routing and call progression states also affect channel state.</p>

<p>  Channels have calls, both fire off events, events have names (<em>CHANNEL_EXECUTE</em>) and fire in specific order for a particular &#8216;action&#8217;, providing a mechanism for constant feedback on the current status of the channel and its associated call. The events fired are affected by the specific channel state e.g <em>CS_HANGUP</em> or <em>CS_DESTROY</em> and, internally, the call state e.g <em>HANGUP</em> or <em>DESTROY</em>.</p>

<p> Its the combination of these three status/state settings (event, channel, &#8216;call/action&#8217;) that reveal the inner workings of whats going on inside FreeSWITCH as it sees things, the channel, and the call. Grouping the channel&#8217;s event chain for a specific action on that channel, and then mapping the channel state changes that take place during that channel&#8217;s lifecycle, and the channel&#8217;s call lifecycle I believe provides value by exposing that internal coordination in such a way it can be readily and repeatably tested in a myriad of combinations.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/fs_specs/blog/2012/02/15/and-theyre-off-the-start-of-fs-specs/">And They&#8217;re Off! The Start of FS_SPECS</a></h2>
    
    
      <p class="meta">
        








  


<time datetime="2012-02-15T19:52:00-05:00" pubdate data-updated="true">Feb 15<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>My name is Deryl R. Doucette. I&#8217;m the originator of, but only one of a team on, fs_specs which means [F]ree[S]witch [SPEC]ification[S]. The group over at The <a href="http://rubyists.com">Rubyists, LLC.</a> has been in on it from the get go. It was through conversations with TJ that this project was born. TJ has contributed great amounts of time, energy, and code. Ken Rice (SwK on freenode) has helped direct the flow of my inquiries, and provided key conceptual information.</p>

<p>So &#8220;What is &#8216;it&#8217;?&#8221;, you&#8217;re probably asking. FS_SPECs is a project to backfill testing into the <a href="http://freeswitch.org">FreeSWITCH Project</a> utilizing the Ruby library <a href="https://github.com/rubyists/freeswitcher">FreeSWITCHeR</a> as the interface to FreeSWITCH in an effort to enhance the stability, and usability, of both projects. The features and scenarios are written using <a href="http://cukes.info">Cucumber</a> (which uses gherkin). We pull in <a href="https://www.relishapp.com/rspec">RSpec</a> for additional matchers. Everything else is <a href="http://ruby-lang.org">Ruby</a>. We are currently using Ruby 1.9.3p0, Cucumber 1.1.4, and RSpec 2.8.0. We use <a href="http://gembundler.com">Bundler</a> for gems management, which currently is 1.0.21. The Ruby environment is managed using <a href="http://rvm.beginrescueend.com">RVM</a>, which I&#8217;m also a team member of, and we utilize RVM&#8217;s per-project .rvmrc file capability.</p>

<p>This is the first post for <a href="http://github.fs-specs.org">fs_specs</a>. I&#8217;m not usually sure what to say in a first post because its one that defines your outlook for that specific project. I&#8217;ve several outlooks, hopes, and thoughts on direction for this project. The first of which is that it be useful in what it does.</p>

<p>I&#8217;ve had the honour of speaking twice now during FreeSWITCH&#8217;s live weekly conference. I&#8217;ve come to realize that I do not, in any way shape or form, have the gift of &#8216;makin dah speech sounds&#8217;.</p>

<p>So, I figure I&#8217;ll fall back to my comfort zone which is writing. I like to write. I can express myself a bit better with the written word. Hopefully, along the way I&#8217;ll be able to express here what I was unable to in the conferences. Much of what I was hoping to point out with regards to testing events within the context of channel and call state changes never made it into the conversation. My brain went for a walk and decided not to take me with it. I was drawing complete blanks. :/ Not fun on life audio.</p>

<p>So, herein is where I&#8217;ll explain from top to bottom what I&#8217;m doing with fs_specs, urls for getting to the code, detailed explanations of the current Cucumber Features and Scenarios, and the exposed event&#8217;s content. On the code front, please be aware that I use the &#8216;master&#8217; branch as the &#8216;stable&#8217; branch. All development is done directly on, or in offshoots of, the &#8216;development&#8217; branch. Pulling master, which is the default, will always pull what is considered &#8216;Stable Release&#8217;.</p>

<p>There might be a bit of meandering as I gather my thoughts and order my information. Trust me, if you saw the editing that goes on <em>before</em> I hit the save button, you would quickly agree the saved is a much cleaner piece than originally written. <grin></p>

<p>Over the next few postings, I plan on taking apart the currently defined Features and their Scenarios on the master branch and explaining them here, along with the end-goal which might necessitate reworking some of the steps. I hope to use the explanations not only to educate on who, what, when, where, and why, but also because it might also serve to streamline my own thought processes thereby creating greater focus. One can hope!</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/fs_specs/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/fs_specs/blog/2012/02/22/interacting-with-voicemail-002-channel-can-interact-with-voicemail-feature/">Interacting With Voicemail</a>
      </li>
    
      <li class="post">
        <a href="/fs_specs/blog/2012/02/17/checking-out-extensions-001-channel-can-dial-extensions-feature/">Checking Out Extensions</a>
      </li>
    
      <li class="post">
        <a href="/fs_specs/blog/2012/02/16/anatomy-of-an-fs-specs-feature-set-000-phone-infrastructure-feature/">Anatomy of an FS_SPECS Feature Set</a>
      </li>
    
      <li class="post">
        <a href="/fs_specs/blog/2012/02/15/stage-fright-gone-brief-synopsis-of-goal/">Stage Fright Gone! Brief Synopsis of Goal</a>
      </li>
    
      <li class="post">
        <a href="/fs_specs/blog/2012/02/15/and-theyre-off-the-start-of-fs-specs/">And They&#8217;re Off! The start of FS_SPECS</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/rubyists">@rubyists</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'rubyists',
            count: 7,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/fs_specs/javascripts/github.js" type="text/javascript"> </script>
</section>




<section class="googleplus">
  <h1>
    <a href="https://plus.google.com/114407361520857511779?rel=author">
      <img src="http://www.google.com/images/icons/ui/gprofile_button-32.png" width="32" height="32">
      Google+
    </a>
  </h1>
</section>



  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2012 - Deryl R. Doucette -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  





  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
